import { generateText } from '../utils/aiClient.js';

/**
 * GitHubPRAgent: Creates a Pull Request on GitHub after fixes are applied
 */
export class GitHubPRAgent {
    constructor(githubToken) {
        this.githubToken = githubToken;
    }

    /**
     * Parses owner and repo name from a GitHub URL
     */
    parseRepo(repoUrl) {
        const match = repoUrl.match(/github\.com\/([^\/]+)\/([^\/]+)/);
        if (!match) throw new Error('Invalid GitHub URL');
        return {
            owner: match[1],
            repo: match[2].replace('.git', '')
        };
    }

    /**
     * Generates a human-readable PR description using Gemini
     */
    async generatePRDescription(fixes, teamName, leaderName) {
        const fixSummaries = fixes
            .filter(f => f.status === 'Fixed')
            .map(f => `- ${f.bugType} in \`${f.file}\` (line ${f.line_number || f.line}): ${f.commit_message || f.fixDescription || 'Fixed automatically'}`)
            .join('\n');

        const prompt = `
      You are a senior software engineer writing a GitHub Pull Request description.
      
      Team: ${teamName} | Leader: ${leaderName}
      
      Fixes applied by the RIFT Autonomous CI/CD Healing Agent:
      ${fixSummaries || 'General improvements and fixes applied.'}
      
      Write a concise, professional Pull Request description in markdown.
      Include:
      1. A brief overview paragraph (2 sentences max)
      2. A "## Changes" section listing the fixes
      3. A "## Testing" section saying automated tests pass
      
      Keep it under 300 words. No extra commentary. Just the markdown.
    `;

        try {
            const description = await generateText(prompt);
            return description;
        } catch (e) {
            // Fallback static description
            return this._buildStaticDescription(fixes, teamName, leaderName);
        }
    }

    _buildStaticDescription(fixes, teamName, leaderName) {
        const fixList = fixes
            .filter(f => f.status === 'Fixed')
            .map(f => `- **${f.bugType}** in \`${f.file}\``)
            .join('\n');

        return `## ðŸ¤– RIFT Autonomous CI/CD Healing Agent

This PR was automatically generated by the RIFT Agent to fix failing tests and code issues.

**Team:** ${teamName} | **Leader:** ${leaderName}

## Changes

${fixList || '- General code quality improvements'}

## Testing

âœ… All automated tests pass after applying these fixes.

---
*Generated by RIFT Autonomous CI/CD Healing Agent*`;
    }

    /**
     * Creates a Pull Request on GitHub
     */
    async createPullRequest(repoUrl, branchName, fixes, teamName, leaderName) {
        if (!this.githubToken) {
            console.warn('No GITHUB_TOKEN set, skipping PR creation');
            return { success: false, reason: 'No GitHub token configured' };
        }

        try {
            const { owner, repo } = this.parseRepo(repoUrl);
            const fixedCount = fixes.filter(f => f.status === 'Fixed').length;

            // Get default branch to use as base
            const repoInfoRes = await fetch(`https://api.github.com/repos/${owner}/${repo}`, {
                headers: {
                    Authorization: `token ${this.githubToken}`,
                    Accept: 'application/vnd.github.v3+json'
                }
            });

            let baseBranch = 'main';
            if (repoInfoRes.ok) {
                const repoInfo = await repoInfoRes.json();
                baseBranch = repoInfo.default_branch || 'main';
            }

            // Generate AI-written PR description
            const prBody = await this.generatePRDescription(fixes, teamName, leaderName);

            const prTitle = `[RIFT Agent] ðŸ¤– Auto-fix: ${fixedCount} issue${fixedCount !== 1 ? 's' : ''} resolved`;

            // Create the PR via GitHub API
            const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/pulls`, {
                method: 'POST',
                headers: {
                    Authorization: `token ${this.githubToken}`,
                    Accept: 'application/vnd.github.v3+json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    title: prTitle,
                    body: prBody,
                    head: branchName,
                    base: baseBranch
                })
            });

            if (!response.ok) {
                const errData = await response.json();
                // PR might already exist (422 = Unprocessable Entity)
                if (response.status === 422) {
                    console.warn('PR may already exist:', errData.message);
                    return { success: false, reason: `PR already exists or branch not pushed: ${errData.message}` };
                }
                throw new Error(`GitHub PR API error ${response.status}: ${errData.message}`);
            }

            const pr = await response.json();
            console.log(`âœ… PR created: ${pr.html_url}`);

            return {
                success: true,
                prUrl: pr.html_url,
                prNumber: pr.number,
                prTitle: pr.title
            };

        } catch (error) {
            console.warn('PR creation failed:', error.message);
            return { success: false, reason: error.message };
        }
    }
}
